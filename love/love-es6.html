<!DOCTYPE html>
<html>

<head>
  <title>满屏爱心</title>
  <style>
    #full-screen {
      cursor: pointer;
      float: right;
      border: none;
      background-color: rgba(255,255,255,0.0);
      color:rgba(255,255,255,0.0);
      margin: 20px;
      font-size: 24px;
    }
    #full-screen:hover {
      font-weight: bold;
      color: white;
    }
  </style>
</head>

<body style="background-color: black">
  <button onclick="openFullscreen()" id="full-screen" title="full-screen">[&nbsp;&nbsp;]</button>
  <canvas id="cavs" style="position:fixed; z-index:-1;"></canvas>
</body>

</html>

<script type="text/javascript">
  /* 获取 documentElement (<html>) 以全屏显示页面 */
  var elem = document.documentElement;
  /* 全屏查看 */
  function openFullscreen() {
    if (elem.requestFullscreen) {
        elem.requestFullscreen();
    } else if (elem.mozRequestFullScreen) { /* Firefox */
        elem.mozRequestFullScreen();
    } else if (elem.webkitRequestFullscreen) { /* Chrome, Safari 和 Opera */
        elem.webkitRequestFullscreen();
    } else if (elem.msRequestFullscreen) { /* IE/Edge */
        elem.msRequestFullscreen();
    }
  }
  class Love {
    constructor(board) {
      this.board = board;
      this.init();
    }
    init() {
      this.maxScale = (Math.random() * 3.2 + 1.2) * this.board.w / 521;
      this.curScale = 1.2 * this.board.w / 521;
      this.x = Math.floor(Math.random() * this.board.w - 40);
      this.y = Math.floor(this.board.h - Math.random() * 200);
      this.ColR = Math.floor(Math.random() * 255);
      this.ColG = Math.floor(Math.random() * 255);
      this.ColB = Math.floor(Math.random() * 255);
      this.alpha = Math.random() * 0.2 + 0.8;
      this.vector = Math.random() * 2 + 1.2;
    }
    draw() {
      if (this.alpha < 0.01) this.init();
      if (this.curScale < this.maxScale) this.curScale += 0.3;
      const x = this.x;
      const y = this.y;
      const s = this.curScale;
      const ctx = this.board.context;
      ctx.fillStyle = "rgba(" + this.ColR + "," + this.ColG + "," + this.ColB + "," + this.alpha + ")";
      ctx.shadowBlur = 10;
      ctx.shadowColor = "rgb(" + this.ColR + "," + this.ColG + "," + this.ColB + ")";
      ctx.beginPath();
      ctx.bezierCurveTo(x + 2.5 * s, y + 2.5 * s, x + 2.0 * s, y, x, y);
      ctx.bezierCurveTo(x - 3.0 * s, y, x - 3.0 * s, y + 3.5 * s, x - 3.0 * s, y + 3.5 * s);
      ctx.bezierCurveTo(x - 3.0 * s, y + 5.5 * s, x - 1.0 * s, y + 7.7 * s, x + 2.5 * s, y + 9.5 * s);
      ctx.bezierCurveTo(x + 6.0 * s, y + 7.7 * s, x + 8.0 * s, y + 5.5 * s, x + 8.0 * s, y + 3.5 * s);
      ctx.bezierCurveTo(x + 8.0 * s, y + 3.5 * s, x + 8.0 * s, y, x + 5.0 * s, y);
      ctx.bezierCurveTo(x + 3.5 * s, y, x + 2.5 * s, y + 2.5 * s, x + 2.5 * s, y + 2.5 * s);
      ctx.fill();
      ctx.closePath();
      this.y -= this.vector;
      this.alpha -= (this.vector / this.board.h);
    }
  }

  class Board {
    constructor(Shape) {
      this.Shape = Shape;
      this.shapes = [];
      const canvas = document.getElementById("cavs");
      this.w = window.innerWidth;
      this.h = window.innerHeight;
      canvas.setAttribute("width", this.w);
      canvas.setAttribute("height", this.h);
      this.context = canvas.getContext("2d");
    }
    create() {
      for (let i = 0; i < this.w / 59; i++) {
        this.shapes.push(new this.Shape(this));
      }
    }
    draw() {
      this.context.clearRect(0, 0, this.w, this.h);
      for (let key in this.shapes) {
        this.shapes[key].draw();
      }
      window.requestAnimationFrame(this.draw.bind(this));
    }
    run() {
      this.create();
      this.draw();
    }
  }

  window.onload = function () {
    new Board(Love).run();
  }
</script>